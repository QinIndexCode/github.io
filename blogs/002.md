## 2025-12-24 JS原型污染漏洞

JavaScript 中的**原型污染（Prototype Pollution）**是一种非常隐蔽且危险的安全漏洞，尤其在处理不可信用户输入时容易被利用。它可能导致**权限提升、任意代码执行、拒绝服务（DoS）**等严重后果。

### 原型污染的基本原理

JavaScript 中几乎所有对象都继承自 `Object.prototype`，而对象的原型可以通过特殊属性 `__proto__`、`prototype` 或 `constructor` 访问和修改。

当我们向一个普通对象动态添加属性时，如果键名恰好是 `__proto__`，就会直接修改该对象的原型对象，从而污染整个原型链。

#### 简单演示

```javascript
// 正常情况：给空对象添加属性
const user = {};
user.name = 'Alice';
console.log(user.name); // 'Alice'

// 原型污染攻击
const maliciousInput = JSON.parse('{"__proto__": {"isAdmin": true}}');

// 假设有一个不安全的深层合并函数（常见于许多库）
function merge(target, source) {
  for (const key in source) {
    target[key] = source[key];
  }
  return target;
}

const cleanObj = {};
merge(cleanObj, maliciousInput);

// 现在所有普通对象的原型都被污染了！
console.log({}.isAdmin);        // true  ← 危险！任意空对象都有 isAdmin 属性
console.log(user.isAdmin);      // true
console.log((new Date()).isAdmin); // true，甚至原生对象也可能受影响
```

攻击者只需要控制输入对象的某个键为 `__proto__`，就能向 `Object.prototype` 注入任意属性，从而影响后续创建的所有对象。

### 常见的特殊键

以下键都会影响原型链（统称为污染入口）：

- `__proto__`        ← 最常见、最直接
- `prototype`        ← 常用于污染构造函数的原型
- `constructor`      ← 可间接访问 prototype

```javascript
// 三种等效的污染方式
obj['__proto__'].polluted = true;
obj.constructor.prototype.polluted = true;
obj['constructor']['prototype'].polluted = true;

// 结果都是：Object.prototype.polluted === true
```

### 真实攻击场景举例

1. **权限绕过**
   ```javascript
   // 服务端校验用户权限
   function isAdmin(user) {
     return user.isAdmin === true;  // 本应从数据库读取
   }

   // 攻击者提交 { "__proto__": { "isAdmin": true } }
   // 导致所有对象默认都有 isAdmin: true → 权限绕过成功
   ```

2. **拒绝服务（DoS）**
   ```javascript
   // 注入一个会导致无限循环或崩溃的 getter
   {"__proto__": {"toString": () => { while(true) {} }}}
   ```

3. **结合其他漏洞实现 RCE（远程代码执行）**
   在某些 Node.js 环境中，污染 `child_process` 或 `fs` 相关原型，可能结合其他 gadget 实现任意命令执行（历史上有多个知名库因此中招，如 lodash < 4.17.11）。

### 如何防御原型污染

1. **避免直接使用用户输入作为对象键进行递归合并**
   - 不要自己写深层 merge 函数
   - 使用安全的库或手动控制合并逻辑

2. **严格校验键名**
   ```javascript
   function safeAssign(target, key, value) {
     if (key === '__proto__' || key === 'prototype' || key === 'constructor') {
       throw new Error('Forbidden property name');
     }
     target[key] = value;
   }
   ```

3. **使用 Object.create(null) 创建无原型对象**
   ```javascript
   const map = Object.create(null);  // 没有 __proto__ 属性，完全安全
   map[userInputKey] = value;        // 即使 key 是 "__proto__" 也只是普通键
   ```

4. **冻结原型（生产环境可考虑）**
   ```javascript
   Object.freeze(Object.prototype);
   // 尝试污染会静默失败（非严格模式）或抛错（严格模式）
   ```

5. **升级依赖库**
   许多知名库（如 lodash、jquery、express 等）都修复过原型污染漏洞，保持依赖最新非常重要。

### 小结

原型污染的核心是：**攻击者通过控制对象键名，修改了所有对象的共享原型**。

它看似“小众”，但在实际 Web 应用中非常危险，尤其是在以下场景：

- 处理 JSON 输入的 API
- 使用深层对象合并的配置系统
- 第三方库未修复旧版本

防御原则只有一句话：**永远不要信任外部输入直接作为对象属性键，尤其是递归处理时**。
